// Copyright 2020 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Brought from: //depot/google3/location/nearby/sharing/proto/wire_format.proto
// At CL 317565061

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v6.30.2
// source: wire_format.proto

package sharing

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type FileMetadata_Type int32

const (
	FileMetadata_UNKNOWN FileMetadata_Type = 0
	FileMetadata_IMAGE   FileMetadata_Type = 1
	FileMetadata_VIDEO   FileMetadata_Type = 2
	FileMetadata_APP     FileMetadata_Type = 3
	FileMetadata_AUDIO   FileMetadata_Type = 4
)

// Enum value maps for FileMetadata_Type.
var (
	FileMetadata_Type_name = map[int32]string{
		0: "UNKNOWN",
		1: "IMAGE",
		2: "VIDEO",
		3: "APP",
		4: "AUDIO",
	}
	FileMetadata_Type_value = map[string]int32{
		"UNKNOWN": 0,
		"IMAGE":   1,
		"VIDEO":   2,
		"APP":     3,
		"AUDIO":   4,
	}
)

func (x FileMetadata_Type) Enum() *FileMetadata_Type {
	p := new(FileMetadata_Type)
	*p = x
	return p
}

func (x FileMetadata_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FileMetadata_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_wire_format_proto_enumTypes[0].Descriptor()
}

func (FileMetadata_Type) Type() protoreflect.EnumType {
	return &file_wire_format_proto_enumTypes[0]
}

func (x FileMetadata_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *FileMetadata_Type) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = FileMetadata_Type(num)
	return nil
}

// Deprecated: Use FileMetadata_Type.Descriptor instead.
func (FileMetadata_Type) EnumDescriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{0, 0}
}

type TextMetadata_Type int32

const (
	TextMetadata_UNKNOWN TextMetadata_Type = 0
	TextMetadata_TEXT    TextMetadata_Type = 1
	// Open with browsers.
	TextMetadata_URL TextMetadata_Type = 2
	// Open with map apps.
	TextMetadata_ADDRESS TextMetadata_Type = 3
	// Dial.
	TextMetadata_PHONE_NUMBER TextMetadata_Type = 4
)

// Enum value maps for TextMetadata_Type.
var (
	TextMetadata_Type_name = map[int32]string{
		0: "UNKNOWN",
		1: "TEXT",
		2: "URL",
		3: "ADDRESS",
		4: "PHONE_NUMBER",
	}
	TextMetadata_Type_value = map[string]int32{
		"UNKNOWN":      0,
		"TEXT":         1,
		"URL":          2,
		"ADDRESS":      3,
		"PHONE_NUMBER": 4,
	}
)

func (x TextMetadata_Type) Enum() *TextMetadata_Type {
	p := new(TextMetadata_Type)
	*p = x
	return p
}

func (x TextMetadata_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TextMetadata_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_wire_format_proto_enumTypes[1].Descriptor()
}

func (TextMetadata_Type) Type() protoreflect.EnumType {
	return &file_wire_format_proto_enumTypes[1]
}

func (x TextMetadata_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *TextMetadata_Type) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = TextMetadata_Type(num)
	return nil
}

// Deprecated: Use TextMetadata_Type.Descriptor instead.
func (TextMetadata_Type) EnumDescriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{1, 0}
}

type WifiCredentialsMetadata_SecurityType int32

const (
	WifiCredentialsMetadata_UNKNOWN_SECURITY_TYPE WifiCredentialsMetadata_SecurityType = 0
	WifiCredentialsMetadata_OPEN                  WifiCredentialsMetadata_SecurityType = 1
	WifiCredentialsMetadata_WPA_PSK               WifiCredentialsMetadata_SecurityType = 2
	WifiCredentialsMetadata_WEP                   WifiCredentialsMetadata_SecurityType = 3
)

// Enum value maps for WifiCredentialsMetadata_SecurityType.
var (
	WifiCredentialsMetadata_SecurityType_name = map[int32]string{
		0: "UNKNOWN_SECURITY_TYPE",
		1: "OPEN",
		2: "WPA_PSK",
		3: "WEP",
	}
	WifiCredentialsMetadata_SecurityType_value = map[string]int32{
		"UNKNOWN_SECURITY_TYPE": 0,
		"OPEN":                  1,
		"WPA_PSK":               2,
		"WEP":                   3,
	}
)

func (x WifiCredentialsMetadata_SecurityType) Enum() *WifiCredentialsMetadata_SecurityType {
	p := new(WifiCredentialsMetadata_SecurityType)
	*p = x
	return p
}

func (x WifiCredentialsMetadata_SecurityType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (WifiCredentialsMetadata_SecurityType) Descriptor() protoreflect.EnumDescriptor {
	return file_wire_format_proto_enumTypes[2].Descriptor()
}

func (WifiCredentialsMetadata_SecurityType) Type() protoreflect.EnumType {
	return &file_wire_format_proto_enumTypes[2]
}

func (x WifiCredentialsMetadata_SecurityType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *WifiCredentialsMetadata_SecurityType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = WifiCredentialsMetadata_SecurityType(num)
	return nil
}

// Deprecated: Use WifiCredentialsMetadata_SecurityType.Descriptor instead.
func (WifiCredentialsMetadata_SecurityType) EnumDescriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{2, 0}
}

type Frame_Version int32

const (
	Frame_UNKNOWN_VERSION Frame_Version = 0
	Frame_V1              Frame_Version = 1
)

// Enum value maps for Frame_Version.
var (
	Frame_Version_name = map[int32]string{
		0: "UNKNOWN_VERSION",
		1: "V1",
	}
	Frame_Version_value = map[string]int32{
		"UNKNOWN_VERSION": 0,
		"V1":              1,
	}
)

func (x Frame_Version) Enum() *Frame_Version {
	p := new(Frame_Version)
	*p = x
	return p
}

func (x Frame_Version) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Frame_Version) Descriptor() protoreflect.EnumDescriptor {
	return file_wire_format_proto_enumTypes[3].Descriptor()
}

func (Frame_Version) Type() protoreflect.EnumType {
	return &file_wire_format_proto_enumTypes[3]
}

func (x Frame_Version) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Frame_Version) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Frame_Version(num)
	return nil
}

// Deprecated: Use Frame_Version.Descriptor instead.
func (Frame_Version) EnumDescriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{3, 0}
}

type V1Frame_FrameType int32

const (
	V1Frame_UNKNOWN_FRAME_TYPE    V1Frame_FrameType = 0
	V1Frame_INTRODUCTION          V1Frame_FrameType = 1
	V1Frame_RESPONSE              V1Frame_FrameType = 2
	V1Frame_PAIRED_KEY_ENCRYPTION V1Frame_FrameType = 3
	V1Frame_PAIRED_KEY_RESULT     V1Frame_FrameType = 4
	V1Frame_CERTIFICATE_INFO      V1Frame_FrameType = 5
	V1Frame_CANCEL                V1Frame_FrameType = 6
)

// Enum value maps for V1Frame_FrameType.
var (
	V1Frame_FrameType_name = map[int32]string{
		0: "UNKNOWN_FRAME_TYPE",
		1: "INTRODUCTION",
		2: "RESPONSE",
		3: "PAIRED_KEY_ENCRYPTION",
		4: "PAIRED_KEY_RESULT",
		5: "CERTIFICATE_INFO",
		6: "CANCEL",
	}
	V1Frame_FrameType_value = map[string]int32{
		"UNKNOWN_FRAME_TYPE":    0,
		"INTRODUCTION":          1,
		"RESPONSE":              2,
		"PAIRED_KEY_ENCRYPTION": 3,
		"PAIRED_KEY_RESULT":     4,
		"CERTIFICATE_INFO":      5,
		"CANCEL":                6,
	}
)

func (x V1Frame_FrameType) Enum() *V1Frame_FrameType {
	p := new(V1Frame_FrameType)
	*p = x
	return p
}

func (x V1Frame_FrameType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (V1Frame_FrameType) Descriptor() protoreflect.EnumDescriptor {
	return file_wire_format_proto_enumTypes[4].Descriptor()
}

func (V1Frame_FrameType) Type() protoreflect.EnumType {
	return &file_wire_format_proto_enumTypes[4]
}

func (x V1Frame_FrameType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *V1Frame_FrameType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = V1Frame_FrameType(num)
	return nil
}

// Deprecated: Use V1Frame_FrameType.Descriptor instead.
func (V1Frame_FrameType) EnumDescriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{4, 0}
}

type ConnectionResponseFrame_Status int32

const (
	ConnectionResponseFrame_UNKNOWN                     ConnectionResponseFrame_Status = 0
	ConnectionResponseFrame_ACCEPT                      ConnectionResponseFrame_Status = 1
	ConnectionResponseFrame_REJECT                      ConnectionResponseFrame_Status = 2
	ConnectionResponseFrame_NOT_ENOUGH_SPACE            ConnectionResponseFrame_Status = 3
	ConnectionResponseFrame_UNSUPPORTED_ATTACHMENT_TYPE ConnectionResponseFrame_Status = 4
	ConnectionResponseFrame_TIMED_OUT                   ConnectionResponseFrame_Status = 5
)

// Enum value maps for ConnectionResponseFrame_Status.
var (
	ConnectionResponseFrame_Status_name = map[int32]string{
		0: "UNKNOWN",
		1: "ACCEPT",
		2: "REJECT",
		3: "NOT_ENOUGH_SPACE",
		4: "UNSUPPORTED_ATTACHMENT_TYPE",
		5: "TIMED_OUT",
	}
	ConnectionResponseFrame_Status_value = map[string]int32{
		"UNKNOWN":                     0,
		"ACCEPT":                      1,
		"REJECT":                      2,
		"NOT_ENOUGH_SPACE":            3,
		"UNSUPPORTED_ATTACHMENT_TYPE": 4,
		"TIMED_OUT":                   5,
	}
)

func (x ConnectionResponseFrame_Status) Enum() *ConnectionResponseFrame_Status {
	p := new(ConnectionResponseFrame_Status)
	*p = x
	return p
}

func (x ConnectionResponseFrame_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ConnectionResponseFrame_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_wire_format_proto_enumTypes[5].Descriptor()
}

func (ConnectionResponseFrame_Status) Type() protoreflect.EnumType {
	return &file_wire_format_proto_enumTypes[5]
}

func (x ConnectionResponseFrame_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *ConnectionResponseFrame_Status) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = ConnectionResponseFrame_Status(num)
	return nil
}

// Deprecated: Use ConnectionResponseFrame_Status.Descriptor instead.
func (ConnectionResponseFrame_Status) EnumDescriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{6, 0}
}

type PairedKeyResultFrame_Status int32

const (
	PairedKeyResultFrame_UNKNOWN PairedKeyResultFrame_Status = 0
	PairedKeyResultFrame_SUCCESS PairedKeyResultFrame_Status = 1
	PairedKeyResultFrame_FAIL    PairedKeyResultFrame_Status = 2
	PairedKeyResultFrame_UNABLE  PairedKeyResultFrame_Status = 3
)

// Enum value maps for PairedKeyResultFrame_Status.
var (
	PairedKeyResultFrame_Status_name = map[int32]string{
		0: "UNKNOWN",
		1: "SUCCESS",
		2: "FAIL",
		3: "UNABLE",
	}
	PairedKeyResultFrame_Status_value = map[string]int32{
		"UNKNOWN": 0,
		"SUCCESS": 1,
		"FAIL":    2,
		"UNABLE":  3,
	}
)

func (x PairedKeyResultFrame_Status) Enum() *PairedKeyResultFrame_Status {
	p := new(PairedKeyResultFrame_Status)
	*p = x
	return p
}

func (x PairedKeyResultFrame_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PairedKeyResultFrame_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_wire_format_proto_enumTypes[6].Descriptor()
}

func (PairedKeyResultFrame_Status) Type() protoreflect.EnumType {
	return &file_wire_format_proto_enumTypes[6]
}

func (x PairedKeyResultFrame_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *PairedKeyResultFrame_Status) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = PairedKeyResultFrame_Status(num)
	return nil
}

// Deprecated: Use PairedKeyResultFrame_Status.Descriptor instead.
func (PairedKeyResultFrame_Status) EnumDescriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{8, 0}
}

// File metadata. Does not include the actual bytes of the file.
// NEXT_ID=6
type FileMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The human readable name of this file (eg. 'Cookbook.pdf').
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The type of file (eg. 'IMAGE' from 'dog.jpg'). Specifying a type helps
	// provide a richer experience on the receiving side.
	Type *FileMetadata_Type `protobuf:"varint,2,opt,name=type,enum=sharing.nearby.FileMetadata_Type,def=0" json:"type,omitempty"`
	// The FILE payload id that will be sent as a follow up containing the actual
	// bytes of the file.
	PayloadId *int64 `protobuf:"varint,3,opt,name=payload_id,json=payloadId" json:"payload_id,omitempty"`
	// The total size of the file.
	Size *int64 `protobuf:"varint,4,opt,name=size" json:"size,omitempty"`
	// The mimeType of file (eg. 'image/jpeg' from 'dog.jpg'). Specifying a
	// mimeType helps provide a richer experience on receiving side.
	MimeType *string `protobuf:"bytes,5,opt,name=mime_type,json=mimeType,def=application/octet-stream" json:"mime_type,omitempty"`
	// A uuid for the attachment. Should be unique across all attachments.
	Id            *int64 `protobuf:"varint,6,opt,name=id" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for FileMetadata fields.
const (
	Default_FileMetadata_Type     = FileMetadata_UNKNOWN
	Default_FileMetadata_MimeType = string("application/octet-stream")
)

func (x *FileMetadata) Reset() {
	*x = FileMetadata{}
	mi := &file_wire_format_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileMetadata) ProtoMessage() {}

func (x *FileMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_wire_format_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileMetadata.ProtoReflect.Descriptor instead.
func (*FileMetadata) Descriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{0}
}

func (x *FileMetadata) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *FileMetadata) GetType() FileMetadata_Type {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return Default_FileMetadata_Type
}

func (x *FileMetadata) GetPayloadId() int64 {
	if x != nil && x.PayloadId != nil {
		return *x.PayloadId
	}
	return 0
}

func (x *FileMetadata) GetSize() int64 {
	if x != nil && x.Size != nil {
		return *x.Size
	}
	return 0
}

func (x *FileMetadata) GetMimeType() string {
	if x != nil && x.MimeType != nil {
		return *x.MimeType
	}
	return Default_FileMetadata_MimeType
}

func (x *FileMetadata) GetId() int64 {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return 0
}

// NEXT_ID=5
type TextMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The title of the text content.
	TextTitle *string `protobuf:"bytes,2,opt,name=text_title,json=textTitle" json:"text_title,omitempty"`
	// The type of text (phone number, url, address, or plain text).
	Type *TextMetadata_Type `protobuf:"varint,3,opt,name=type,enum=sharing.nearby.TextMetadata_Type,def=0" json:"type,omitempty"`
	// The BYTE payload id that will be sent as a follow up containing the actual
	// bytes of the text.
	PayloadId *int64 `protobuf:"varint,4,opt,name=payload_id,json=payloadId" json:"payload_id,omitempty"`
	// The size of the text content.
	Size *int64 `protobuf:"varint,5,opt,name=size" json:"size,omitempty"`
	// A uuid for the attachment. Should be unique across all attachments.
	Id            *int64 `protobuf:"varint,6,opt,name=id" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for TextMetadata fields.
const (
	Default_TextMetadata_Type = TextMetadata_UNKNOWN
)

func (x *TextMetadata) Reset() {
	*x = TextMetadata{}
	mi := &file_wire_format_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TextMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TextMetadata) ProtoMessage() {}

func (x *TextMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_wire_format_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TextMetadata.ProtoReflect.Descriptor instead.
func (*TextMetadata) Descriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{1}
}

func (x *TextMetadata) GetTextTitle() string {
	if x != nil && x.TextTitle != nil {
		return *x.TextTitle
	}
	return ""
}

func (x *TextMetadata) GetType() TextMetadata_Type {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return Default_TextMetadata_Type
}

func (x *TextMetadata) GetPayloadId() int64 {
	if x != nil && x.PayloadId != nil {
		return *x.PayloadId
	}
	return 0
}

func (x *TextMetadata) GetSize() int64 {
	if x != nil && x.Size != nil {
		return *x.Size
	}
	return 0
}

func (x *TextMetadata) GetId() int64 {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return 0
}

// NEXT_ID=5
type WifiCredentialsMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Wifi network name. This will be sent in introduction.
	Ssid *string `protobuf:"bytes,2,opt,name=ssid" json:"ssid,omitempty"`
	// The security type of network (OPEN, WPA_PSK, WEP).
	SecurityType *WifiCredentialsMetadata_SecurityType `protobuf:"varint,3,opt,name=security_type,json=securityType,enum=sharing.nearby.WifiCredentialsMetadata_SecurityType,def=0" json:"security_type,omitempty"`
	// The BYTE payload id that will be sent as a follow up containing the
	// password.
	PayloadId *int64 `protobuf:"varint,4,opt,name=payload_id,json=payloadId" json:"payload_id,omitempty"`
	// A uuid for the attachment. Should be unique across all attachments.
	Id            *int64 `protobuf:"varint,5,opt,name=id" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for WifiCredentialsMetadata fields.
const (
	Default_WifiCredentialsMetadata_SecurityType = WifiCredentialsMetadata_UNKNOWN_SECURITY_TYPE
)

func (x *WifiCredentialsMetadata) Reset() {
	*x = WifiCredentialsMetadata{}
	mi := &file_wire_format_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WifiCredentialsMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WifiCredentialsMetadata) ProtoMessage() {}

func (x *WifiCredentialsMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_wire_format_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WifiCredentialsMetadata.ProtoReflect.Descriptor instead.
func (*WifiCredentialsMetadata) Descriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{2}
}

func (x *WifiCredentialsMetadata) GetSsid() string {
	if x != nil && x.Ssid != nil {
		return *x.Ssid
	}
	return ""
}

func (x *WifiCredentialsMetadata) GetSecurityType() WifiCredentialsMetadata_SecurityType {
	if x != nil && x.SecurityType != nil {
		return *x.SecurityType
	}
	return Default_WifiCredentialsMetadata_SecurityType
}

func (x *WifiCredentialsMetadata) GetPayloadId() int64 {
	if x != nil && x.PayloadId != nil {
		return *x.PayloadId
	}
	return 0
}

func (x *WifiCredentialsMetadata) GetId() int64 {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return 0
}

// A frame used when sending messages over the wire.
// NEXT_ID=3
type Frame struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Version *Frame_Version         `protobuf:"varint,1,opt,name=version,enum=sharing.nearby.Frame_Version" json:"version,omitempty"`
	// Right now there's only 1 version, but if there are more, exactly one of
	// the following fields will be set.
	V1            *V1Frame `protobuf:"bytes,2,opt,name=v1" json:"v1,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Frame) Reset() {
	*x = Frame{}
	mi := &file_wire_format_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Frame) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Frame) ProtoMessage() {}

func (x *Frame) ProtoReflect() protoreflect.Message {
	mi := &file_wire_format_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Frame.ProtoReflect.Descriptor instead.
func (*Frame) Descriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{3}
}

func (x *Frame) GetVersion() Frame_Version {
	if x != nil && x.Version != nil {
		return *x.Version
	}
	return Frame_UNKNOWN_VERSION
}

func (x *Frame) GetV1() *V1Frame {
	if x != nil {
		return x.V1
	}
	return nil
}

// NEXT_ID=7
type V1Frame struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Type  *V1Frame_FrameType     `protobuf:"varint,1,opt,name=type,enum=sharing.nearby.V1Frame_FrameType" json:"type,omitempty"`
	// Exactly one of the following fields will be set.
	Introduction        *IntroductionFrame        `protobuf:"bytes,2,opt,name=introduction" json:"introduction,omitempty"`
	ConnectionResponse  *ConnectionResponseFrame  `protobuf:"bytes,3,opt,name=connection_response,json=connectionResponse" json:"connection_response,omitempty"`
	PairedKeyEncryption *PairedKeyEncryptionFrame `protobuf:"bytes,4,opt,name=paired_key_encryption,json=pairedKeyEncryption" json:"paired_key_encryption,omitempty"`
	PairedKeyResult     *PairedKeyResultFrame     `protobuf:"bytes,5,opt,name=paired_key_result,json=pairedKeyResult" json:"paired_key_result,omitempty"`
	CertificateInfo     *CertificateInfoFrame     `protobuf:"bytes,6,opt,name=certificate_info,json=certificateInfo" json:"certificate_info,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *V1Frame) Reset() {
	*x = V1Frame{}
	mi := &file_wire_format_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *V1Frame) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*V1Frame) ProtoMessage() {}

func (x *V1Frame) ProtoReflect() protoreflect.Message {
	mi := &file_wire_format_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use V1Frame.ProtoReflect.Descriptor instead.
func (*V1Frame) Descriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{4}
}

func (x *V1Frame) GetType() V1Frame_FrameType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return V1Frame_UNKNOWN_FRAME_TYPE
}

func (x *V1Frame) GetIntroduction() *IntroductionFrame {
	if x != nil {
		return x.Introduction
	}
	return nil
}

func (x *V1Frame) GetConnectionResponse() *ConnectionResponseFrame {
	if x != nil {
		return x.ConnectionResponse
	}
	return nil
}

func (x *V1Frame) GetPairedKeyEncryption() *PairedKeyEncryptionFrame {
	if x != nil {
		return x.PairedKeyEncryption
	}
	return nil
}

func (x *V1Frame) GetPairedKeyResult() *PairedKeyResultFrame {
	if x != nil {
		return x.PairedKeyResult
	}
	return nil
}

func (x *V1Frame) GetCertificateInfo() *CertificateInfoFrame {
	if x != nil {
		return x.CertificateInfo
	}
	return nil
}

// An introduction packet sent by the sending side. Contains a list of files
// they'd like to share.
// NEXT_ID=4
type IntroductionFrame struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	FileMetadata []*FileMetadata        `protobuf:"bytes,1,rep,name=file_metadata,json=fileMetadata" json:"file_metadata,omitempty"`
	TextMetadata []*TextMetadata        `protobuf:"bytes,2,rep,name=text_metadata,json=textMetadata" json:"text_metadata,omitempty"`
	// The required app package to open the content. May be null.
	RequiredPackage         *string                    `protobuf:"bytes,3,opt,name=required_package,json=requiredPackage" json:"required_package,omitempty"`
	WifiCredentialsMetadata []*WifiCredentialsMetadata `protobuf:"bytes,4,rep,name=wifi_credentials_metadata,json=wifiCredentialsMetadata" json:"wifi_credentials_metadata,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *IntroductionFrame) Reset() {
	*x = IntroductionFrame{}
	mi := &file_wire_format_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IntroductionFrame) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IntroductionFrame) ProtoMessage() {}

func (x *IntroductionFrame) ProtoReflect() protoreflect.Message {
	mi := &file_wire_format_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IntroductionFrame.ProtoReflect.Descriptor instead.
func (*IntroductionFrame) Descriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{5}
}

func (x *IntroductionFrame) GetFileMetadata() []*FileMetadata {
	if x != nil {
		return x.FileMetadata
	}
	return nil
}

func (x *IntroductionFrame) GetTextMetadata() []*TextMetadata {
	if x != nil {
		return x.TextMetadata
	}
	return nil
}

func (x *IntroductionFrame) GetRequiredPackage() string {
	if x != nil && x.RequiredPackage != nil {
		return *x.RequiredPackage
	}
	return ""
}

func (x *IntroductionFrame) GetWifiCredentialsMetadata() []*WifiCredentialsMetadata {
	if x != nil {
		return x.WifiCredentialsMetadata
	}
	return nil
}

// A response packet sent by the receiving side. Accepts or rejects the list of
// files.
// NEXT_ID=2
type ConnectionResponseFrame struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The receiving side's response.
	Status        *ConnectionResponseFrame_Status `protobuf:"varint,1,opt,name=status,enum=sharing.nearby.ConnectionResponseFrame_Status" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectionResponseFrame) Reset() {
	*x = ConnectionResponseFrame{}
	mi := &file_wire_format_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectionResponseFrame) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectionResponseFrame) ProtoMessage() {}

func (x *ConnectionResponseFrame) ProtoReflect() protoreflect.Message {
	mi := &file_wire_format_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectionResponseFrame.ProtoReflect.Descriptor instead.
func (*ConnectionResponseFrame) Descriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{6}
}

func (x *ConnectionResponseFrame) GetStatus() ConnectionResponseFrame_Status {
	if x != nil && x.Status != nil {
		return *x.Status
	}
	return ConnectionResponseFrame_UNKNOWN
}

// A paired key encryption packet sent between devices, contains signed data.
// NEXT_ID=3
type PairedKeyEncryptionFrame struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The encrypted data in byte array format.
	SignedData []byte `protobuf:"bytes,1,opt,name=signed_data,json=signedData" json:"signed_data,omitempty"`
	// The hash of a certificate id.
	SecretIdHash []byte `protobuf:"bytes,2,opt,name=secret_id_hash,json=secretIdHash" json:"secret_id_hash,omitempty"`
	// An optional encrypted data in byte array format.
	OptionalSignedData []byte `protobuf:"bytes,3,opt,name=optional_signed_data,json=optionalSignedData" json:"optional_signed_data,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *PairedKeyEncryptionFrame) Reset() {
	*x = PairedKeyEncryptionFrame{}
	mi := &file_wire_format_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PairedKeyEncryptionFrame) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PairedKeyEncryptionFrame) ProtoMessage() {}

func (x *PairedKeyEncryptionFrame) ProtoReflect() protoreflect.Message {
	mi := &file_wire_format_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PairedKeyEncryptionFrame.ProtoReflect.Descriptor instead.
func (*PairedKeyEncryptionFrame) Descriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{7}
}

func (x *PairedKeyEncryptionFrame) GetSignedData() []byte {
	if x != nil {
		return x.SignedData
	}
	return nil
}

func (x *PairedKeyEncryptionFrame) GetSecretIdHash() []byte {
	if x != nil {
		return x.SecretIdHash
	}
	return nil
}

func (x *PairedKeyEncryptionFrame) GetOptionalSignedData() []byte {
	if x != nil {
		return x.OptionalSignedData
	}
	return nil
}

// A paired key verification result packet sent between devices.
// NEXT_ID=2
type PairedKeyResultFrame struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The verification result.
	Status        *PairedKeyResultFrame_Status `protobuf:"varint,1,opt,name=status,enum=sharing.nearby.PairedKeyResultFrame_Status" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PairedKeyResultFrame) Reset() {
	*x = PairedKeyResultFrame{}
	mi := &file_wire_format_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PairedKeyResultFrame) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PairedKeyResultFrame) ProtoMessage() {}

func (x *PairedKeyResultFrame) ProtoReflect() protoreflect.Message {
	mi := &file_wire_format_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PairedKeyResultFrame.ProtoReflect.Descriptor instead.
func (*PairedKeyResultFrame) Descriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{8}
}

func (x *PairedKeyResultFrame) GetStatus() PairedKeyResultFrame_Status {
	if x != nil && x.Status != nil {
		return *x.Status
	}
	return PairedKeyResultFrame_UNKNOWN
}

// A package containing certificate info to be shared to remote device offline.
// NEXT_ID=2
type CertificateInfoFrame struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The public certificates to be shared with remote devices.
	PublicCertificate []*PublicCertificate `protobuf:"bytes,1,rep,name=public_certificate,json=publicCertificate" json:"public_certificate,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *CertificateInfoFrame) Reset() {
	*x = CertificateInfoFrame{}
	mi := &file_wire_format_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CertificateInfoFrame) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CertificateInfoFrame) ProtoMessage() {}

func (x *CertificateInfoFrame) ProtoReflect() protoreflect.Message {
	mi := &file_wire_format_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CertificateInfoFrame.ProtoReflect.Descriptor instead.
func (*CertificateInfoFrame) Descriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{9}
}

func (x *CertificateInfoFrame) GetPublicCertificate() []*PublicCertificate {
	if x != nil {
		return x.PublicCertificate
	}
	return nil
}

// A public certificate from the local device.
// NEXT_ID=8
type PublicCertificate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique id of the public certificate.
	SecretId []byte `protobuf:"bytes,1,opt,name=secret_id,json=secretId" json:"secret_id,omitempty"`
	// A bytes representation of a Secret Key owned by contact, to decrypt the
	// metadata_key stored within the advertisement.
	AuthenticityKey []byte `protobuf:"bytes,2,opt,name=authenticity_key,json=authenticityKey" json:"authenticity_key,omitempty"`
	// A bytes representation a public key of X509Certificate, owned by contact,
	// to decrypt encrypted UKEY2 (from Nearby Connections API) as a hand shake in
	// contact verification phase.
	PublicKey []byte `protobuf:"bytes,3,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	// The time in millis from epoch when this certificate becomes effective.
	StartTime *int64 `protobuf:"varint,4,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// The time in millis from epoch when this certificate expires.
	EndTime *int64 `protobuf:"varint,5,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
	// The encrypted metadata in bytes, contains personal information of the
	// device/user who created this certificate. Needs to be decrypted into bytes,
	// and converted back to EncryptedMetadata object to access fields.
	EncryptedMetadataBytes []byte `protobuf:"bytes,6,opt,name=encrypted_metadata_bytes,json=encryptedMetadataBytes" json:"encrypted_metadata_bytes,omitempty"`
	// The tag for verifying metadata_encryption_key.
	MetadataEncryptionKeyTag []byte `protobuf:"bytes,7,opt,name=metadata_encryption_key_tag,json=metadataEncryptionKeyTag" json:"metadata_encryption_key_tag,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *PublicCertificate) Reset() {
	*x = PublicCertificate{}
	mi := &file_wire_format_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublicCertificate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublicCertificate) ProtoMessage() {}

func (x *PublicCertificate) ProtoReflect() protoreflect.Message {
	mi := &file_wire_format_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublicCertificate.ProtoReflect.Descriptor instead.
func (*PublicCertificate) Descriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{10}
}

func (x *PublicCertificate) GetSecretId() []byte {
	if x != nil {
		return x.SecretId
	}
	return nil
}

func (x *PublicCertificate) GetAuthenticityKey() []byte {
	if x != nil {
		return x.AuthenticityKey
	}
	return nil
}

func (x *PublicCertificate) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *PublicCertificate) GetStartTime() int64 {
	if x != nil && x.StartTime != nil {
		return *x.StartTime
	}
	return 0
}

func (x *PublicCertificate) GetEndTime() int64 {
	if x != nil && x.EndTime != nil {
		return *x.EndTime
	}
	return 0
}

func (x *PublicCertificate) GetEncryptedMetadataBytes() []byte {
	if x != nil {
		return x.EncryptedMetadataBytes
	}
	return nil
}

func (x *PublicCertificate) GetMetadataEncryptionKeyTag() []byte {
	if x != nil {
		return x.MetadataEncryptionKeyTag
	}
	return nil
}

// NEXT_ID=3
type WifiCredentials struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Wi-Fi password.
	Password *string `protobuf:"bytes,1,opt,name=password" json:"password,omitempty"`
	// True if the network is a hidden network that is not broadcasting its SSID.
	// Default is false.
	HiddenSsid    *bool `protobuf:"varint,2,opt,name=hidden_ssid,json=hiddenSsid,def=0" json:"hidden_ssid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for WifiCredentials fields.
const (
	Default_WifiCredentials_HiddenSsid = bool(false)
)

func (x *WifiCredentials) Reset() {
	*x = WifiCredentials{}
	mi := &file_wire_format_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WifiCredentials) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WifiCredentials) ProtoMessage() {}

func (x *WifiCredentials) ProtoReflect() protoreflect.Message {
	mi := &file_wire_format_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WifiCredentials.ProtoReflect.Descriptor instead.
func (*WifiCredentials) Descriptor() ([]byte, []int) {
	return file_wire_format_proto_rawDescGZIP(), []int{11}
}

func (x *WifiCredentials) GetPassword() string {
	if x != nil && x.Password != nil {
		return *x.Password
	}
	return ""
}

func (x *WifiCredentials) GetHiddenSsid() bool {
	if x != nil && x.HiddenSsid != nil {
		return *x.HiddenSsid
	}
	return Default_WifiCredentials_HiddenSsid
}

var File_wire_format_proto protoreflect.FileDescriptor

const file_wire_format_proto_rawDesc = "" +
	"\n" +
	"\x11wire_format.proto\x12\x0esharing.nearby\"\x9b\x02\n" +
	"\fFileMetadata\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12>\n" +
	"\x04type\x18\x02 \x01(\x0e2!.sharing.nearby.FileMetadata.Type:\aUNKNOWNR\x04type\x12\x1d\n" +
	"\n" +
	"payload_id\x18\x03 \x01(\x03R\tpayloadId\x12\x12\n" +
	"\x04size\x18\x04 \x01(\x03R\x04size\x125\n" +
	"\tmime_type\x18\x05 \x01(\t:\x18application/octet-streamR\bmimeType\x12\x0e\n" +
	"\x02id\x18\x06 \x01(\x03R\x02id\"=\n" +
	"\x04Type\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\t\n" +
	"\x05IMAGE\x10\x01\x12\t\n" +
	"\x05VIDEO\x10\x02\x12\a\n" +
	"\x03APP\x10\x03\x12\t\n" +
	"\x05AUDIO\x10\x04\"\xf7\x01\n" +
	"\fTextMetadata\x12\x1d\n" +
	"\n" +
	"text_title\x18\x02 \x01(\tR\ttextTitle\x12>\n" +
	"\x04type\x18\x03 \x01(\x0e2!.sharing.nearby.TextMetadata.Type:\aUNKNOWNR\x04type\x12\x1d\n" +
	"\n" +
	"payload_id\x18\x04 \x01(\x03R\tpayloadId\x12\x12\n" +
	"\x04size\x18\x05 \x01(\x03R\x04size\x12\x0e\n" +
	"\x02id\x18\x06 \x01(\x03R\x02id\"E\n" +
	"\x04Type\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\b\n" +
	"\x04TEXT\x10\x01\x12\a\n" +
	"\x03URL\x10\x02\x12\v\n" +
	"\aADDRESS\x10\x03\x12\x10\n" +
	"\fPHONE_NUMBER\x10\x04\"\x99\x02\n" +
	"\x17WifiCredentialsMetadata\x12\x12\n" +
	"\x04ssid\x18\x02 \x01(\tR\x04ssid\x12p\n" +
	"\rsecurity_type\x18\x03 \x01(\x0e24.sharing.nearby.WifiCredentialsMetadata.SecurityType:\x15UNKNOWN_SECURITY_TYPER\fsecurityType\x12\x1d\n" +
	"\n" +
	"payload_id\x18\x04 \x01(\x03R\tpayloadId\x12\x0e\n" +
	"\x02id\x18\x05 \x01(\x03R\x02id\"I\n" +
	"\fSecurityType\x12\x19\n" +
	"\x15UNKNOWN_SECURITY_TYPE\x10\x00\x12\b\n" +
	"\x04OPEN\x10\x01\x12\v\n" +
	"\aWPA_PSK\x10\x02\x12\a\n" +
	"\x03WEP\x10\x03\"\x91\x01\n" +
	"\x05Frame\x127\n" +
	"\aversion\x18\x01 \x01(\x0e2\x1d.sharing.nearby.Frame.VersionR\aversion\x12'\n" +
	"\x02v1\x18\x02 \x01(\v2\x17.sharing.nearby.V1FrameR\x02v1\"&\n" +
	"\aVersion\x12\x13\n" +
	"\x0fUNKNOWN_VERSION\x10\x00\x12\x06\n" +
	"\x02V1\x10\x01\"\xfc\x04\n" +
	"\aV1Frame\x125\n" +
	"\x04type\x18\x01 \x01(\x0e2!.sharing.nearby.V1Frame.FrameTypeR\x04type\x12E\n" +
	"\fintroduction\x18\x02 \x01(\v2!.sharing.nearby.IntroductionFrameR\fintroduction\x12X\n" +
	"\x13connection_response\x18\x03 \x01(\v2'.sharing.nearby.ConnectionResponseFrameR\x12connectionResponse\x12\\\n" +
	"\x15paired_key_encryption\x18\x04 \x01(\v2(.sharing.nearby.PairedKeyEncryptionFrameR\x13pairedKeyEncryption\x12P\n" +
	"\x11paired_key_result\x18\x05 \x01(\v2$.sharing.nearby.PairedKeyResultFrameR\x0fpairedKeyResult\x12O\n" +
	"\x10certificate_info\x18\x06 \x01(\v2$.sharing.nearby.CertificateInfoFrameR\x0fcertificateInfo\"\x97\x01\n" +
	"\tFrameType\x12\x16\n" +
	"\x12UNKNOWN_FRAME_TYPE\x10\x00\x12\x10\n" +
	"\fINTRODUCTION\x10\x01\x12\f\n" +
	"\bRESPONSE\x10\x02\x12\x19\n" +
	"\x15PAIRED_KEY_ENCRYPTION\x10\x03\x12\x15\n" +
	"\x11PAIRED_KEY_RESULT\x10\x04\x12\x14\n" +
	"\x10CERTIFICATE_INFO\x10\x05\x12\n" +
	"\n" +
	"\x06CANCEL\x10\x06\"\xa9\x02\n" +
	"\x11IntroductionFrame\x12A\n" +
	"\rfile_metadata\x18\x01 \x03(\v2\x1c.sharing.nearby.FileMetadataR\ffileMetadata\x12A\n" +
	"\rtext_metadata\x18\x02 \x03(\v2\x1c.sharing.nearby.TextMetadataR\ftextMetadata\x12)\n" +
	"\x10required_package\x18\x03 \x01(\tR\x0frequiredPackage\x12c\n" +
	"\x19wifi_credentials_metadata\x18\x04 \x03(\v2'.sharing.nearby.WifiCredentialsMetadataR\x17wifiCredentialsMetadata\"\xd6\x01\n" +
	"\x17ConnectionResponseFrame\x12F\n" +
	"\x06status\x18\x01 \x01(\x0e2..sharing.nearby.ConnectionResponseFrame.StatusR\x06status\"s\n" +
	"\x06Status\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\n" +
	"\n" +
	"\x06ACCEPT\x10\x01\x12\n" +
	"\n" +
	"\x06REJECT\x10\x02\x12\x14\n" +
	"\x10NOT_ENOUGH_SPACE\x10\x03\x12\x1f\n" +
	"\x1bUNSUPPORTED_ATTACHMENT_TYPE\x10\x04\x12\r\n" +
	"\tTIMED_OUT\x10\x05\"\x93\x01\n" +
	"\x18PairedKeyEncryptionFrame\x12\x1f\n" +
	"\vsigned_data\x18\x01 \x01(\fR\n" +
	"signedData\x12$\n" +
	"\x0esecret_id_hash\x18\x02 \x01(\fR\fsecretIdHash\x120\n" +
	"\x14optional_signed_data\x18\x03 \x01(\fR\x12optionalSignedData\"\x95\x01\n" +
	"\x14PairedKeyResultFrame\x12C\n" +
	"\x06status\x18\x01 \x01(\x0e2+.sharing.nearby.PairedKeyResultFrame.StatusR\x06status\"8\n" +
	"\x06Status\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\v\n" +
	"\aSUCCESS\x10\x01\x12\b\n" +
	"\x04FAIL\x10\x02\x12\n" +
	"\n" +
	"\x06UNABLE\x10\x03\"h\n" +
	"\x14CertificateInfoFrame\x12P\n" +
	"\x12public_certificate\x18\x01 \x03(\v2!.sharing.nearby.PublicCertificateR\x11publicCertificate\"\xad\x02\n" +
	"\x11PublicCertificate\x12\x1b\n" +
	"\tsecret_id\x18\x01 \x01(\fR\bsecretId\x12)\n" +
	"\x10authenticity_key\x18\x02 \x01(\fR\x0fauthenticityKey\x12\x1d\n" +
	"\n" +
	"public_key\x18\x03 \x01(\fR\tpublicKey\x12\x1d\n" +
	"\n" +
	"start_time\x18\x04 \x01(\x03R\tstartTime\x12\x19\n" +
	"\bend_time\x18\x05 \x01(\x03R\aendTime\x128\n" +
	"\x18encrypted_metadata_bytes\x18\x06 \x01(\fR\x16encryptedMetadataBytes\x12=\n" +
	"\x1bmetadata_encryption_key_tag\x18\a \x01(\fR\x18metadataEncryptionKeyTag\"U\n" +
	"\x0fWifiCredentials\x12\x1a\n" +
	"\bpassword\x18\x01 \x01(\tR\bpassword\x12&\n" +
	"\vhidden_ssid\x18\x02 \x01(\b:\x05falseR\n" +
	"hiddenSsidB9H\x03Z5github.com/ACLzz/qshare/internal/protobuf/gen/sharing"

var (
	file_wire_format_proto_rawDescOnce sync.Once
	file_wire_format_proto_rawDescData []byte
)

func file_wire_format_proto_rawDescGZIP() []byte {
	file_wire_format_proto_rawDescOnce.Do(func() {
		file_wire_format_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_wire_format_proto_rawDesc), len(file_wire_format_proto_rawDesc)))
	})
	return file_wire_format_proto_rawDescData
}

var file_wire_format_proto_enumTypes = make([]protoimpl.EnumInfo, 7)
var file_wire_format_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_wire_format_proto_goTypes = []any{
	(FileMetadata_Type)(0),                    // 0: sharing.nearby.FileMetadata.Type
	(TextMetadata_Type)(0),                    // 1: sharing.nearby.TextMetadata.Type
	(WifiCredentialsMetadata_SecurityType)(0), // 2: sharing.nearby.WifiCredentialsMetadata.SecurityType
	(Frame_Version)(0),                        // 3: sharing.nearby.Frame.Version
	(V1Frame_FrameType)(0),                    // 4: sharing.nearby.V1Frame.FrameType
	(ConnectionResponseFrame_Status)(0),       // 5: sharing.nearby.ConnectionResponseFrame.Status
	(PairedKeyResultFrame_Status)(0),          // 6: sharing.nearby.PairedKeyResultFrame.Status
	(*FileMetadata)(nil),                      // 7: sharing.nearby.FileMetadata
	(*TextMetadata)(nil),                      // 8: sharing.nearby.TextMetadata
	(*WifiCredentialsMetadata)(nil),           // 9: sharing.nearby.WifiCredentialsMetadata
	(*Frame)(nil),                             // 10: sharing.nearby.Frame
	(*V1Frame)(nil),                           // 11: sharing.nearby.V1Frame
	(*IntroductionFrame)(nil),                 // 12: sharing.nearby.IntroductionFrame
	(*ConnectionResponseFrame)(nil),           // 13: sharing.nearby.ConnectionResponseFrame
	(*PairedKeyEncryptionFrame)(nil),          // 14: sharing.nearby.PairedKeyEncryptionFrame
	(*PairedKeyResultFrame)(nil),              // 15: sharing.nearby.PairedKeyResultFrame
	(*CertificateInfoFrame)(nil),              // 16: sharing.nearby.CertificateInfoFrame
	(*PublicCertificate)(nil),                 // 17: sharing.nearby.PublicCertificate
	(*WifiCredentials)(nil),                   // 18: sharing.nearby.WifiCredentials
}
var file_wire_format_proto_depIdxs = []int32{
	0,  // 0: sharing.nearby.FileMetadata.type:type_name -> sharing.nearby.FileMetadata.Type
	1,  // 1: sharing.nearby.TextMetadata.type:type_name -> sharing.nearby.TextMetadata.Type
	2,  // 2: sharing.nearby.WifiCredentialsMetadata.security_type:type_name -> sharing.nearby.WifiCredentialsMetadata.SecurityType
	3,  // 3: sharing.nearby.Frame.version:type_name -> sharing.nearby.Frame.Version
	11, // 4: sharing.nearby.Frame.v1:type_name -> sharing.nearby.V1Frame
	4,  // 5: sharing.nearby.V1Frame.type:type_name -> sharing.nearby.V1Frame.FrameType
	12, // 6: sharing.nearby.V1Frame.introduction:type_name -> sharing.nearby.IntroductionFrame
	13, // 7: sharing.nearby.V1Frame.connection_response:type_name -> sharing.nearby.ConnectionResponseFrame
	14, // 8: sharing.nearby.V1Frame.paired_key_encryption:type_name -> sharing.nearby.PairedKeyEncryptionFrame
	15, // 9: sharing.nearby.V1Frame.paired_key_result:type_name -> sharing.nearby.PairedKeyResultFrame
	16, // 10: sharing.nearby.V1Frame.certificate_info:type_name -> sharing.nearby.CertificateInfoFrame
	7,  // 11: sharing.nearby.IntroductionFrame.file_metadata:type_name -> sharing.nearby.FileMetadata
	8,  // 12: sharing.nearby.IntroductionFrame.text_metadata:type_name -> sharing.nearby.TextMetadata
	9,  // 13: sharing.nearby.IntroductionFrame.wifi_credentials_metadata:type_name -> sharing.nearby.WifiCredentialsMetadata
	5,  // 14: sharing.nearby.ConnectionResponseFrame.status:type_name -> sharing.nearby.ConnectionResponseFrame.Status
	6,  // 15: sharing.nearby.PairedKeyResultFrame.status:type_name -> sharing.nearby.PairedKeyResultFrame.Status
	17, // 16: sharing.nearby.CertificateInfoFrame.public_certificate:type_name -> sharing.nearby.PublicCertificate
	17, // [17:17] is the sub-list for method output_type
	17, // [17:17] is the sub-list for method input_type
	17, // [17:17] is the sub-list for extension type_name
	17, // [17:17] is the sub-list for extension extendee
	0,  // [0:17] is the sub-list for field type_name
}

func init() { file_wire_format_proto_init() }
func file_wire_format_proto_init() {
	if File_wire_format_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_wire_format_proto_rawDesc), len(file_wire_format_proto_rawDesc)),
			NumEnums:      7,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_wire_format_proto_goTypes,
		DependencyIndexes: file_wire_format_proto_depIdxs,
		EnumInfos:         file_wire_format_proto_enumTypes,
		MessageInfos:      file_wire_format_proto_msgTypes,
	}.Build()
	File_wire_format_proto = out.File
	file_wire_format_proto_goTypes = nil
	file_wire_format_proto_depIdxs = nil
}
